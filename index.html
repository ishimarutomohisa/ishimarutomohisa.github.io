<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<link rel="icon" href="https://static.wikia.nocookie.net/disneymagicalkingdoms/images/e/ea/Update-16-app_icon.png" type="image/png">
<title>DMK Update</title>
<!-- Swiper CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
<!-- å¼•å…¥ Font Awesome å›¾æ ‡åº“ -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<!-- Highcharts Gantt CDN -->
<script src="https://code.highcharts.com/gantt/highcharts-gantt.js"></script>
<!-- Swiper JS -->
<script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
<!-- å¼•å…¥æ•°æ®æ–‡ä»¶ -->
<script src="data.js"></script> <!-- ä»»åŠ¡ç¿»è¯‘æ•°æ®åº“ -->
<script src="update.js"></script> <!-- âš ï¸ æ–°å¢è¿™è¡Œï¼šç‰ˆæœ¬å’Œæ’æœŸé…ç½® -->

<style>
  :root {
    --primary-blue: #1976d2;
    --primary-hover: #1565c0;
    --bg-color: #f0f2f5;
    --card-bg: #ffffff;
    --text-color: #333;
    --border-color: #ddd;
    --scrollbar-width: 8px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: var(--bg-color);
    color: var(--text-color);
    height: 100vh;
    overflow: hidden; /* Prevent body scroll, let Swiper handle it */
  }
  
  /* --- æ–°å¢ï¼šé¡¶éƒ¨å¯¼èˆªæ æ ·å¼ --- */
  .top-nav {
    height: 50px; /* å›ºå®šé«˜åº¦ */
    width: 100%;
    background: #fff;
    display: flex;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    z-index: 100;
    position: relative;
  }

  .nav-item {
    flex: 1; /* å‡åˆ†å®½åº¦ */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    font-weight: 600;
    color: #666;
    cursor: pointer;
    transition: all 0.3s;
    border-bottom: 3px solid transparent;
  }

  /* æ¿€æ´»çŠ¶æ€ */
  .nav-item.active {
    color: var(--primary-blue);
    border-bottom-color: var(--primary-blue);
    background-color: #f0f7ff;
  }

  /* --- Swiper Structure --- */
  .swiper {
    width: 100%;
    height: 100vh;
    /* âš ï¸ å…³é”®ï¼šé«˜åº¦å‡å»å¯¼èˆªæ çš„ 50px */
    height: calc(100vh - 50px);
    height: calc(100dvh - 50px); 
    margin-top: 0;
  }

  .swiper-slide {
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding: 20px;
    box-sizing: border-box;
    background: var(--bg-color);
    /* Hide scrollbar for slide itself to look cleaner */
    scrollbar-width: none; 
    -ms-overflow-style: none;
  }
  
  .swiper-slide::-webkit-scrollbar {
    display: none;
  }

  .swiper-pagination-bullet {
    width: 10px;
    height: 10px;
    background-color: var(--primary-blue);
    opacity: 0.5;
  }

  .swiper-pagination-bullet-active {
    opacity: 1;
  }

  /* --- Components --- */
  .content-card {
    background: var(--card-bg);
    width: 100%;
    max-width: 1000px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    padding: 24px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    margin: 0 auto;
  }

/* --- æ ‡é¢˜æ å¸ƒå±€ (Desktop: å·¦å³åˆ†å¸ƒ) --- */
  h1 {
    display: flex;
    flex-wrap: wrap; /* å…è®¸æ¢è¡Œï¼Œé˜²æ­¢çª„å±æŒ¤å‹ */
    align-items: center;
    justify-content: space-between; /* âš ï¸ æ ¸å¿ƒï¼šè®©æ ‡é¢˜åœ¨å·¦ï¼ŒæŒ‰é’®åœ¨å³ */
    gap: 12px;
    margin: 0 0 16px 0;
    width: 100%;
  }

  /* æ ‡é¢˜æ–‡å­—æ ·å¼ */
  .outline-effect {
    color: #207CE2;
    text-shadow: 1px 1px 0 #fff, 2px 2px 4px rgba(30, 58, 138, 0.3);
    font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
    font-size: clamp(20px, 4vw, 32px);
    /* æ¡Œé¢ç«¯ä¸éœ€è¦ margin-right: autoï¼Œé  justify-content æ’‘å¼€ */
  }

  /* --- æŒ‰é’®ç»„å¸ƒå±€ (Desktop: ç´§å‡‘æ’åˆ—) --- */
  .btn-group {
    display: flex;
    gap: 10px;
    align-items: center;
    /* âš ï¸ æ¡Œé¢ç«¯ä¸è¦è®¾å®½åº¦100%ï¼Œå¦åˆ™ä¼šæ¢è¡Œ */
    width: auto; 
    margin: 0;
  }

  /* --- çº¯å›¾æ ‡åœ†å½¢æŒ‰é’® --- */
  .social-btn {
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%;
    
    display: flex;
    align-items: center;
    justify-content: center;
    
    font-size: 18px;
    color: #fff;
    cursor: pointer;
    transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    -webkit-tap-highlight-color: transparent;
    outline: none;
    
    /* âš ï¸ ç¦æ­¢å‹ç¼©ï¼Œä¿è¯åœ†å½¢ */
    flex: 0 0 auto;
  }

  .social-btn:active {
    transform: scale(0.9);
    filter: brightness(0.9);
  }

  /* --- ğŸ“± ç§»åŠ¨ç«¯ä¸“å±ä¼˜åŒ– ğŸ“± --- */
  @media (max-width: 768px) {
    /* 1. æ ‡é¢˜æ åœ¨ç§»åŠ¨ç«¯å˜ä¸ºå‚ç›´å †å ï¼ŒæŒ‰é’®åœ¨ä¸‹æ–¹ */
    h1 {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .outline-effect {
        width: 100%;
        margin-bottom: 5px;
    }

    /* 2. æŒ‰é’®ç»„ï¼šGrid + Scroll Snap */
    .btn-group {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* ä¸€è¡Œ3ä¸ª */
      justify-items: center;
      width: 100%;
      gap: 15px 0; /* è¡Œé—´è·15pxï¼Œåˆ—é—´è·0(ç”±justifyå¤„ç†) */
      
      /* âš ï¸ é«˜åº¦è®¡ç®—ï¼š
         æŒ‰é’®(48px) + ä¸Šå†…è¾¹è·(12px) + ä¸‹å†…è¾¹è·(12px) = 72px 
         ç¨å¾®å¤šç»™ä¸€ç‚¹ç‚¹å®¹é”™ç©ºé—´ï¼Œè®¾ä¸º 74px */
      height: 60px;
      padding: 12px 0; 
      
      /* æ»šåŠ¨è®¾ç½® */
      overflow-y: auto;
      overflow-x: hidden;
      
      /* ğŸŒŸ æ ¸å¿ƒï¼šå‚ç›´æ»šåŠ¨æ•æ‰ (Snap) ğŸŒŸ */
      scroll-snap-type: y mandatory; 
      
      /* éšè—æ»šåŠ¨æ¡ */
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
      
      /* åº•éƒ¨é®ç½©æç¤º */
      mask-image: linear-gradient(to bottom, black 60%, transparent 100%);
      -webkit-mask-image: linear-gradient(to bottom, black 60%, transparent 100%);
    }
    
    .btn-group::-webkit-scrollbar { display: none; }

    /* 3. æŒ‰é’®æ ·å¼é€‚é… */
    .social-btn {
      width: 48px;
      height: 48px;
      font-size: 22px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
      
      /* ğŸŒŸ é…åˆçˆ¶çº§ï¼Œå‘Šè¯‰æµè§ˆå™¨è¿™é‡Œæ˜¯å¸é™„ç‚¹ ğŸŒŸ */
      scroll-snap-align: center;
    }
  }

  /* --- å„å¹³å°é¢œè‰²å®šä¹‰ --- */
  
  /* Patch Note: æ¸å˜è‰² */
  .btn-patch { background: linear-gradient(rgb(41, 210, 247) 6.16%, rgb(41, 143, 247) 95.06%); }
  
  /* Wiki: é’è‰² */
  .btn-wiki { background-color: #520044; }

  /* Facebook: è“è‰² */
  .btn-fb { background-color: #1877F2; }

  /* Discord: ç´«è“è‰² */
  .btn-discord { background-color: #5865F2; }

  /* Github: æ·±è‰² */
  .btn-github { background-color: #24292e; }

  /* Reddit: æ©™è‰² */
  .btn-reddit { background-color: #FF5700; }

  h1 button {
    background: var(--primary-blue);
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.2s;
  }

  h1 button:hover {
    background: var(--primary-hover);
  }

  .note {
    color: #666;
    font-size: 14px;
    margin-bottom: 12px;
    background: #fff8e1;
    padding: 8px 12px;
    border-radius: 4px;
    border-left: 4px solid #ffc107;
    /* ğŸ‘‡ğŸ‘‡ğŸ‘‡ æ–°å¢è¿™ 3 è¡Œ ğŸ‘‡ğŸ‘‡ğŸ‘‡ */
    max-height: 100px;       /* é™åˆ¶æœ€å¤§é«˜åº¦ï¼Œé¿å…å æ®å¤ªå¤šå±å¹• */
    overflow-y: auto;        /* å†…å®¹è¶…é•¿æ—¶ï¼Œæ˜¾ç¤ºå†…éƒ¨æ»šåŠ¨æ¡ */
    white-space: pre-wrap;   /* ç¡®ä¿é•¿æ–‡æœ¬è‡ªåŠ¨æ¢è¡Œ */
  }

  .top-image {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
    margin-bottom: 20px;
    background-color: #eee; /* Placeholder color */
    min-height: 100px;
  }

/* --- Chart --- */
  .chart-wrapper {
    width: 100%;
    overflow-x: auto;          /* âš ï¸ æ ¸å¿ƒï¼šå…è®¸æ¨ªå‘æ»šåŠ¨ */
    -webkit-overflow-scrolling: touch; /* iOS é¡ºæ»‘æ»šåŠ¨æ”¯æŒ */
    border: 1px solid #eee;
    border-radius: 6px;
    background: #fff;
    padding-bottom: 4px;
    
    /* âš ï¸ ç¡®ä¿è¯¥åŒºåŸŸä¸è§¦å‘ Swiper ç¿»é¡µï¼Œéœ€é…åˆ JS ä¸­çš„ noSwipingClass */
    touch-action: pan-x; 
    
    height: auto; 
    min-height: 300px;
    overscroll-behavior-x: contain; /* é˜²æ­¢æ»šåŠ¨åˆ°åº•éƒ¨æ—¶è§¦å‘æµè§ˆå™¨çš„åé€€ */
  }
  
  .chart-wrapper::-webkit-scrollbar { height: 6px; } /* æ»šåŠ¨æ¡ç¨å¾®å˜ç»† */
  .chart-wrapper::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
  
  /* Highcharts å®¹å™¨ */
  #container { 
    display: block;
    /* âš ï¸ å®½åº¦å°†ç”± JS æ ¹æ®æ—¥æœŸè·¨åº¦åŠ¨æ€è®¡ç®— */
    /* é«˜åº¦ç”± JS æ§åˆ¶ */
  }

  /* --- Translator Page --- */
  .translator-page {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: flex-start;
  }

  .translator-container {
    width: 100%;
    /* ç§»é™¤max-widthé™åˆ¶ä»¥åˆ©ç”¨å¤§å± */
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }

  .translator-container h2 {
    color: #207CE2;
    text-align: center;
    margin: 0 0 20px 0;
    font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
    text-shadow: 1px 1px 0 #fff, 2px 2px 4px rgba(30, 58, 138, 0.3);
    font-size: 32px;
  }

  .translator-content {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    flex: 1;
  }

  .translator-box {
    flex: 1;
    min-width: 300px; /* Minimum width before stacking */
    display: flex;
    flex-direction: column;
  }

  .translator-box label {
    font-weight: bold;
    margin-bottom: 8px;
    color: #333;
    font-size: 16px;
  }

  /* Input Textarea */
  .translator-box textarea {
    width: 100%;
    height: 400px;
    padding: 15px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 15px;
    resize: none;
    box-sizing: border-box;
    background-color: #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    line-height: 1.5;
    white-space: pre-wrap;
  }

  .translator-box textarea:focus {
    border-color: var(--primary-blue);
    outline: none;
  }

  /* Table Wrapper */
  .table-wrapper {
    width: 100%;
    min-height: 400px; /* Match textarea height */
	height: auto;
    overflow: auto; /* Enable both scrollbars */
    border: 2px solid var(--border-color);
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
  }

  /* Custom Scrollbars */
  textarea::-webkit-scrollbar, 
  .table-wrapper::-webkit-scrollbar {
    width: var(--scrollbar-width);
    height: var(--scrollbar-width);
  }
  textarea::-webkit-scrollbar-track,
  .table-wrapper::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  textarea::-webkit-scrollbar-thumb,
  .table-wrapper::-webkit-scrollbar-thumb {
    background: #ccc;
    border-radius: 4px;
  }
  textarea::-webkit-scrollbar-thumb:hover,
  .table-wrapper::-webkit-scrollbar-thumb:hover {
    background: #999;
  }

  /* Table Styles */
  .dmk-table {
    width: 100%;
    border-collapse: collapse;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
  }

  .dmk-table thead th {
    position: sticky;
    top: 0;
    background-color: #f8f9fa;
    color: var(--primary-blue);
    padding: 12px 10px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e0e0e0;
    cursor: pointer;
    z-index: 10;
    white-space: nowrap;
    user-select: none;
  }
  
  .dmk-table thead th:hover { background-color: #e3f2fd; }

  /* Sort Indicators */
  .dmk-table thead th::after { content: 'â†•'; font-size: 12px; margin-left: 5px; opacity: 0.3; }
  .dmk-table thead th.asc::after { content: 'â†‘'; opacity: 1; color: var(--primary-blue); }
  .dmk-table thead th.desc::after { content: 'â†“'; opacity: 1; color: var(--primary-blue); }

  .dmk-table tbody tr { border-bottom: 1px solid #eee; }
  .dmk-table tbody tr:nth-of-type(even) { background-color: #fcfcfc; }
  .dmk-table tbody tr:hover { background-color: #f0f7ff; }
  
  .dmk-table tbody td {
    padding: 10px;
    line-height: 1.4;
    white-space: nowrap; 
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Controls */
  .translator-controls {
    margin: 20px 0;
    display: flex;
    justify-content: center;
    width: 100%;
  }

  .generate-btn {
    background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);
    color: white;
    border: none;
    border-radius: 50px;
    padding: 12px 48px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4);
    transition: transform 0.2s, box-shadow 0.2s;
    outline: none;
  }
  
  .generate-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(25, 118, 210, 0.6);
  }
  
  .generate-btn:active { transform: translateY(1px); }

  #tableStats {
    margin-top: 10px;
    font-size: 13px;
    color: #666;
    text-align: right;
  }

/* ç§»åŠ¨ç«¯é€‚é… */
  @media (max-width: 768px) {
    .content-card { padding: 15px; }
    h1 { flex-direction: column; align-items: flex-start; }
    .btn-group { width: 100%; }
    h1 button { flex: 1; text-align: center; }
    
    .translator-content { flex-direction: column; gap: 15px; }
    .translator-box textarea, .table-wrapper { min-height: 250px; height: auto;}

    /* --- è¡¨æ ¼ç§»åŠ¨ç«¯ä¼˜åŒ–å¼€å§‹ --- */

    /* 1. å¼ºåˆ¶éšè—æ¨ªå‘æ»šåŠ¨æ¡ */
    .table-wrapper {
      overflow-x: hidden; 
    }
    
    .dmk-table { 
      font-size: 12px; 
      table-layout: fixed; /* å›ºå®šå¸ƒå±€ï¼Œç¡®ä¿å®½åº¦ç”Ÿæ•ˆ */
      width: 100%;
    }

    /* å…è®¸å†…å®¹æ¢è¡Œ */
    .dmk-table tbody td { 
      white-space: normal;
      word-break: break-word;
      vertical-align: middle;
    }

    /* è¡¨å¤´ä¸æ¢è¡Œ */
    .dmk-table thead th {
      white-space: nowrap; 
      padding: 8px 4px;
    }

    /* éšè—ç¬¬4ã€5åˆ— */
    .dmk-table th:nth-child(4), .dmk-table td:nth-child(4),
    .dmk-table th:nth-child(5), .dmk-table td:nth-child(5) {
      display: none;
    }

    /* --- åˆ—å®½ç²¾ç»†è°ƒæ•´ --- */
    
    /* 1. è§’è‰²åï¼š25% */
    .dmk-table th:nth-child(1), .dmk-table td:nth-child(1) { 
      width: 25%; 
      padding: 8px 4px;
    }
    
    /* 2. ä»»åŠ¡åï¼š60% (æœ€å¤§åŒ–ç©ºé—´) */
    .dmk-table th:nth-child(2), .dmk-table td:nth-child(2) { 
      width: 60%; 
      font-weight: bold;
      padding: 8px 4px;
    }
    
    /* 3. æ—¶é•¿ï¼š15% (æçª„æ¨¡å¼) */
    .dmk-table th:nth-child(3), .dmk-table td:nth-child(3) { 
      width: 15%; 
      text-align: center;
      padding: 8px 0; /* å»æ‰å·¦å³å†…è¾¹è·ï¼Œé˜²æ­¢æ–‡å­—è¢«æŒ¤ä¸‹å» */
      white-space: nowrap;
    }
    
    /* --- è¡¨æ ¼ç§»åŠ¨ç«¯ä¼˜åŒ–ç»“æŸ --- */
  }
</style>
</head>
<body>

  <!-- ğŸ‘‡ğŸ‘‡ğŸ‘‡ æ–°å¢ï¼šé¡¶éƒ¨å¯¼èˆªèœå• ğŸ‘‡ğŸ‘‡ğŸ‘‡ -->
  <nav class="top-nav">
    <!-- data-index å¯¹åº” swiper çš„ slide ç´¢å¼• -->
    <div class="nav-item active" data-index="0">Update Info</div>
    <div class="nav-item" data-index="1">Translator</div>
  </nav>
  <!-- ğŸ‘†ğŸ‘†ğŸ‘† æ–°å¢ç»“æŸ ğŸ‘†ğŸ‘†ğŸ‘† -->

  <div class="swiper">
    <div class="swiper-wrapper">
      
      <!-- Slide 1: Patch Info & Gantt -->
      <div class="swiper-slide">
        <div class="content-card">
          <h1>
            <span id="headerTitle" class="outline-effect">DMK Update</span>
            <div class="btn-group swiper-no-swiping">
              <!-- Patch Note -->
              <button id="btnPatch" class="social-btn btn-patch" title="Patch Note">
                <i class="fa-solid fa-file-lines"></i>
              </button>
              
              <!-- Wiki -->
              <button id="btnWiki" class="social-btn btn-wiki" title="Wiki">
                <i class="fa-solid fa-book-open"></i>
              </button>
              
              <!-- Facebook -->
              <button class="social-btn btn-fb" title="Facebook" onclick="window.open('https://www.facebook.com/DisneyMagicKingdoms')">
                <i class="fa-brands fa-facebook-f"></i>
              </button>
              
              <!-- Discord -->
              <button class="social-btn btn-discord" title="Discord" onclick="window.open('https://discord.com/channels/981942496630304818/1288901443511910511')">
                <i class="fa-brands fa-discord"></i>
              </button>
              
              <!-- Github -->
              <button class="social-btn btn-github" title="Github" onclick="window.open('https://github.com/ishimarutomohisa/ishimarutomohisa.github.io')">
                <i class="fa-brands fa-github"></i>
              </button>
              
              <!-- Reddit -->
              <button class="social-btn btn-reddit" title="Reddit" onclick="window.open('https://www.reddit.com/r/disneymagickingdoms/')">
                <i class="fa-brands fa-reddit-alien"></i>
              </button>
            </div>
          </h1>
          
          <div id="headerNote" class="note" style="display: none;"></div>
          
          <!-- ğŸ‘‡ğŸ‘‡ğŸ‘‡ ä¿®æ”¹åï¼šsrc ä¸ºç©ºï¼Œç­‰å¾… JS å¡«å…… ğŸ‘‡ğŸ‘‡ğŸ‘‡ -->
		<img id="topImage" class="top-image" src="" alt="Disney Magic Kingdoms Artwork" />
          
          <div class="chart-wrapper no-swipe">
            <div id="container"></div>
          </div>
        </div>
      </div>

      <!-- Slide 2: Task Translator -->
      <div class="swiper-slide">
        <div class="translator-page">
          <div class="translator-container">
            <h2>ä»»åŠ¡ä¿¡æ¯ç”Ÿæˆå™¨</h2>
            
            <div class="translator-content">
              <!-- Input -->
              <div class="translator-box">
                <label for="inputData">è¾“å…¥ä»»åŠ¡åˆ—è¡¨ (æ ¼å¼: è§’è‰² - ä»»åŠ¡å)</label>
                <textarea id="inputData" placeholder="ä¾‹å¦‚ï¼š
Atta - Review a Report
Atta - Have Fun at the Circus
Dot - It's Just a Rock"></textarea>
              </div>
              
              <!-- Output -->
              <div class="translator-box">
                <label>ç”Ÿæˆç»“æœ (ç‚¹å‡»è¡¨å¤´æ’åº)</label>
                <div class="table-wrapper" id="resultTableContainer">
                  <table class="dmk-table" id="resultTable">
                    <thead>
                      <tr>
                        <th onclick="sortTable(0)">è§’è‰²</th>
                        <th onclick="sortTable(1)">ä»»åŠ¡</th>
                        <th onclick="sortTable(2)">æ—¶é•¿</th>
                        <th onclick="sortTable(3)">å»ºç­‘</th>
                        <th onclick="sortTable(4)">å…¶ä»–</th>
                      </tr>
                    </thead>
                    <tbody id="tableBody">
                      <tr><td colspan="5" style="text-align:center; color:#999; padding:20px;">ç­‰å¾…ç”Ÿæˆæ•°æ®...</td></tr>
                    </tbody>
                  </table>
                </div>
                <div id="tableStats"></div>
              </div>
            </div>
            
            <div class="translator-controls">
              <button class="generate-btn" onclick="translateTasks()">âœ¨ ç”Ÿæˆä¿¡æ¯ âœ¨</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
// ==========================================
// 1. GLOBAL CONFIG & INITIALIZATION
// ==========================================
// âš ï¸ æ³¨æ„ï¼šCONFIG.version ç°åœ¨ç”± update.js æä¾›

document.addEventListener('DOMContentLoaded', function() {
  // æ£€æŸ¥ update.js æ˜¯å¦åŠ è½½
  if (typeof CONFIG === 'undefined') {
    alert("é”™è¯¯ï¼šæœªæ‰¾åˆ°é…ç½®æ–‡ä»¶ update.js");
    return;
  }

  // Swiper Init (ä¿æŒä¸å˜)
  const swiper = new Swiper('.swiper', {
    direction: 'horizontal', 
    slidesPerView: 1,
    spaceBetween: 0,
    mousewheel: {
      forceToAxis: true,
      sensitivity: 1,
      releaseOnEdges: true,
      thresholdDelta: 50 
    },
    keyboard: { enabled: true },
    threshold: 10, 
    noSwipingClass: 'chart-wrapper', 
  });

  // ğŸ‘‡ğŸ‘‡ğŸ‘‡ æ–°å¢ï¼šèœå•æ è”åŠ¨é€»è¾‘ ğŸ‘‡ğŸ‘‡ğŸ‘‡
  const navItems = document.querySelectorAll('.nav-item');

  // 1. ç‚¹å‡»èœå• -> åˆ‡æ¢ Swiper
  navItems.forEach((item, index) => {
    item.addEventListener('click', () => {
      swiper.slideTo(index);
    });
  });
  
  swiper.on('slideChange', function() {
    const activeIndex = swiper.activeIndex;
    
    navItems.forEach(item => item.classList.remove('active'));
    // æ ¹æ®ç´¢å¼•æ‰¾åˆ°å¯¹åº”çš„èœå•é¡¹å¹¶æ¿€æ´»
    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾ navItems çš„é¡ºåºå’Œ slide é¡ºåºä¸€è‡´
    if(navItems[activeIndex]) {
        navItems[activeIndex].classList.add('active');
    }
  });
  
  // Page Content Init (ä½¿ç”¨ update.js ä¸­çš„ CONFIG)
  const headerTitle = document.getElementById('headerTitle');
  if(headerTitle) headerTitle.innerText = `DMK Update ${CONFIG.version}`;
  
  // ğŸ‘‡ğŸ‘‡ğŸ‘‡ æ–°å¢ï¼šNote å…¬å‘Šæ æ§åˆ¶é€»è¾‘ ğŸ‘‡ğŸ‘‡ğŸ‘‡
const noteEl = document.getElementById('headerNote');
if (noteEl) {
  // æ£€æŸ¥ CONFIG.note æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºç©º
  if (CONFIG.note && CONFIG.note.trim() !== '') {
    noteEl.innerHTML = CONFIG.note; // ä½¿ç”¨ innerHTML æ”¯æŒç®€å•çš„ bold æˆ– link
    noteEl.style.display = 'block'; // æ˜¾ç¤ºå…ƒç´ 
  } else {
    noteEl.style.display = 'none';  // éšè—å…ƒç´ 
  }
}
// ğŸ‘†ğŸ‘†ğŸ‘† ç»“æŸ Note é€»è¾‘ ğŸ‘†ğŸ‘†ğŸ‘†
  
  const btnPatch = document.getElementById('btnPatch');
  if(btnPatch) btnPatch.onclick = () => window.open(`https://www.disney-magic-kingdoms.com/news/patchnote_upd${CONFIG.version}`);
  
  const btnWiki = document.getElementById('btnWiki');
  if(btnWiki) btnWiki.onclick = () => window.open(`https://dmk.fandom.com/wiki/Category:Update_${CONFIG.version}`);

  // Image Handling (ä¿®æ”¹åçš„é€»è¾‘)
  const img = document.getElementById('topImage');
  if(img) {
    // 1. ä» CONFIG ä¸­è·å–åœ°å€å¹¶èµ‹å€¼
    if (CONFIG.topImage && CONFIG.topImage !== '') {
        img.src = CONFIG.topImage;
    } else {
        // å¦‚æœæ²¡é…ç½®å›¾ç‰‡ï¼Œç›´æ¥éšè—
        img.style.display = 'none';
    }

    // 2. é”™è¯¯/è¶…æ—¶å¤„ç† (ä¿æŒåŸæœ‰é€»è¾‘ï¼Œé˜²æ­¢å›¾ç‰‡åŠ è½½å¤±è´¥ç•™ç™½)
    const timer = setTimeout(() => { if(!img.complete) img.style.display = 'none'; }, 5000);
    img.onload = () => clearTimeout(timer);
    img.onerror = () => { clearTimeout(timer); img.style.display = 'none'; };
  }
});

// ==========================================
// 2. GANTT CHART LOGIC (Fixed Time & Dynamic PlotLines)
// ==========================================
(function() {
  if (typeof schedules === 'undefined') {
    console.error("schedules is undefined. Check update.js");
    return;
  }

  const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#3F51B5', '#00BCD4'];

  // æ—¶é—´è®¡ç®—å‡½æ•° (ä¿æŒ 23ç‚¹ UTC)
  function toUtcMs(ymd) {
    const parts = ymd.split('-').map(Number);
    return Date.UTC(parts[0], parts[1]-1, parts[2], 23);
  }
  
  function endToUtcMsInclusive(ymd) {
    const parts = ymd.split('-').map(Number);
    return Date.UTC(parts[0], parts[1]-1, parts[2], 23);
  }

  const nowMs = Date.now() + 8*3600*1000;

  // --- 1. å¤„ç†æ•°æ® (Series Data) ---
  const seriesData = [];
  const categories = [];
  const plotBands = [];
  let yIndex = 0;
  let colorIdx = 0;

  schedules.forEach((group, gIdx) => {
    const tasks = group.tasks.sort((a,b) => a.start.localeCompare(b.start));
    const lanes = [];
    
    tasks.forEach(task => {
      const start = toUtcMs(task.start);
      const end = endToUtcMsInclusive(task.end);
      let placed = false;
      
      for(let lane of lanes) {
        if(start >= lane[lane.length-1].end) { 
          lane.push({ ...task, start, end });
          placed = true;
          break;
        }
      }
      if(!placed) lanes.push([{ ...task, start, end }]);
    });

    const startY = yIndex;
    lanes.forEach((lane, lIdx) => {
      categories.push(lIdx === 0 ? group.resource : '');
      lane.forEach(t => {
        seriesData.push({
          id: `${group.resource}_${t.label}_${Math.random()}`,
          name: t.label,
          start: t.start,
          end: t.end,
          y: yIndex,
          color: colors[colorIdx++ % colors.length]
        });
      });
      yIndex++;
    });

    plotBands.push({
      from: startY - 0.5,
      to: yIndex - 0.5,
      color: gIdx % 2 === 0 ? 'rgba(250,250,250,0.9)' : 'rgba(245,245,255,0.95)'
    });
  });

  // --- 2. åŠ¨æ€æ„å»ºæ ‡çº¿ (Plot Lines) ---
  const finalPlotLines = [];

  // (A) æ·»åŠ  "ä»Šå¤©" çš„æ ‡çº¿ (å›ºå®šå­˜åœ¨)
  finalPlotLines.push({
    value: nowMs,
    color: '#FF3B30',
    width: 2,
    dashStyle: 'ShortDash',
    zIndex: 3,
    label: { rotation: 0, x: 9, y: -4, text: 'ï¸ğŸ”»', align: 'right', style: { color: '#FF3B30' } }
  });

  // (B) æ·»åŠ æ¥è‡ª update.js çš„ç‰¹æ®Šæ—¥æœŸæ ‡çº¿
  if (typeof specialDates !== 'undefined' && Array.isArray(specialDates)) {
    specialDates.forEach(item => {
      finalPlotLines.push({
        value: toUtcMs(item.date), // ä½¿ç”¨é…ç½®ä¸­çš„æ—¥æœŸ
        color: item.color || '#30C2FF', // é»˜è®¤è“è‰²
        width: 2,
        dashStyle: 'ShortDash',
        zIndex: 2,
        label: { 
          rotation: 0, 
          x: 9, 
          y: -4, 
          text: item.label, // ä½¿ç”¨é…ç½®ä¸­çš„å›¾æ ‡/æ–‡å­—
          align: 'right',
          style: { color: item.color || '#30C2FF' } // æ–‡å­—é¢œè‰²åŒçº¿æ¡é¢œè‰²
        }
      });
    });
  }

  const minStartMs = seriesData.length > 0 ? Math.min(...seriesData.map(d => d.start)) : Date.now();
  const xAxisMin = minStartMs - (24*3600*1000);

// --- 3. ç”Ÿæˆå›¾è¡¨ (å“åº”å¼å®½åº¦é€»è¾‘) ---
  document.addEventListener('DOMContentLoaded', () => {
    
    // è·å–å®¹å™¨å’Œå½“å‰å±å¹•å®½åº¦
    const container = document.getElementById('container');
    const screenWidth = window.innerWidth;
    const isDesktop = screenWidth >= 1000; // âš ï¸ åˆ¤æ–­æ˜¯å¦ä¸ºå¤§å±

    // è®¡ç®—æ—¶é—´è·¨åº¦ï¼ˆç”¨äºç§»åŠ¨ç«¯è®¡ç®—å®½åº¦ï¼Œæˆ–å¤§å±ç¡®å®šXè½´èŒƒå›´ï¼‰
    const maxEndMs = seriesData.length > 0 ? Math.max(...seriesData.map(d => d.end)) : (nowMs + 86400000);
    
    let finalWidth;

    if (isDesktop) {
        // ğŸŸ¢ å¤§å±æ¨¡å¼ï¼šå®½åº¦è‡ªé€‚åº”ï¼Œä¸äº§ç”Ÿæ»šåŠ¨æ¡
        container.style.width = '100%'; 
    } else {
        // ğŸ”µ ç§»åŠ¨ç«¯æ¨¡å¼ï¼šæ ¹æ®å¤©æ•°è®¡ç®—å®½åº¦ï¼Œå¼ºåˆ¶æ¨ªå‘æ»šåŠ¨
        const totalDays = Math.ceil((maxEndMs - xAxisMin) / (24 * 3600 * 1000));
        const pxPerDay = 25; // æ¯å¤© 50px
        const wrapperWidth = document.querySelector('.chart-wrapper').clientWidth || screenWidth;
        finalWidth = Math.max(wrapperWidth, totalDays * pxPerDay);
        
        container.style.width = `${finalWidth}px`; // å¼ºåˆ¶è®¾ç½®åƒç´ å®½åº¦
    }

    // Highcharts åˆå§‹åŒ–
    Highcharts.ganttChart('container', {
      chart: { 
        height: Math.max(300, categories.length * 30 + 60), 
        style: { fontFamily: 'inherit' } 
      },
      title: { text: undefined },
      xAxis: [{
        grid: { enabled: true },
        tickInterval: 24 * 3600 * 1000,
        labels: { format: '{value:%d}', style: { fontSize: '11px' } },
        min: xAxisMin,
        max: maxEndMs,
        plotLines: finalPlotLines 
      }],
      yAxis: { 
        categories, 
        reversed: true, 
        grid: { enabled: true }, 
        labels: { enabled: false }, 
        plotBands 
      },
      series: [{ 
        name: 'Tasks', 
        data: seriesData, 
        dataLabels: { 
          enabled: true, 
          format: '{point.name}', 
          style: { 
              color: 'white', 
              textOutline: '2px contrast', 
              fontWeight: 'normal', 
              fontSize: '11px',
              // å¤§å±å…è®¸æ¢è¡Œä»¥æ˜¾ç¤ºæ›´å¤šä¿¡æ¯ï¼Œå°å±å¼ºåˆ¶ä¸æ¢è¡Œ
              whiteSpace: isDesktop ? 'normal' : 'nowrap' 
          } 
        },
        borderWidth: 0
      }],
      tooltip: { 
	  //xDateFormat: '%Y-%m-%d %H:%M' 
	  enabled: false 
	  },
      credits: { enabled: false }
    });
    
    // âš ï¸ ä»…åœ¨å°å±å¹•ï¼ˆæœ‰æ»šåŠ¨æ¡æ—¶ï¼‰è‡ªåŠ¨æ»šåŠ¨åˆ°ä»Šå¤©
    if (!isDesktop) {
        setTimeout(() => {
            const chartDiv = document.querySelector('.chart-wrapper');
            const todayLine = nowMs;
            const totalMs = maxEndMs - xAxisMin;
            const percent = (todayLine - xAxisMin) / totalMs;
            
            // é‡æ–°è·å–ä¸€ä¸‹è®¾ç½®åçš„å®½åº¦
            const currentWidth = parseInt(container.style.width); 
            const wrapperW = chartDiv.clientWidth;

            const scrollPos = (percent * currentWidth) - (wrapperW / 2);
            
            if(chartDiv && scrollPos > 0) {
                chartDiv.scrollLeft = scrollPos;
            }
        }, 500);
    }

  });
})();

// ==========================================
// 3. TRANSLATOR LOGIC (Optimized)
// ==========================================

let taskDatabase = [];
let currentTableData = [];
let sortDirection = {};

// 1. Data Parsing
function initDatabase() {
  try {
    // æ£€æŸ¥å¤–éƒ¨æ–‡ä»¶æ˜¯å¦åŠ è½½æˆåŠŸ
    if (typeof rawDataSource === 'undefined') {
      console.error("rawDataSource is undefined. Check if data.js is loaded.");
      document.querySelector('#tableBody').innerHTML = '<tr><td colspan="5" style="color:red;text-align:center;">é”™è¯¯ï¼šæœªæ‰¾åˆ°æ•°æ®æº (data.js)</td></tr>';
      return;
    }

    let clean = rawDataSource.replace(/--\[=\[[\s\S]*?--\]=\]/g, ''); // Remove block comments
    clean = clean.replace(/--.*/g, ''); // Remove line comments
    clean = clean.replace(/^return\s*\{/, '').replace(/\}\s*$/, '').trim();
    
    // Split by rows ensuring we catch the structure {"..."}
    const rowMatches = clean.match(/\{[^}]+\}/g);
    
    if (rowMatches) {
        taskDatabase = rowMatches.map(rowStr => {
            // Remove outer braces
            const content = rowStr.slice(1, -1);
            // Split by comma, handling quotes roughly
            const parts = [];
            let current = '';
            let inQuote = false;
            for(let char of content) {
                if(char === '"') { inQuote = !inQuote; continue; } // Skip quotes
                if(char === ',' && !inQuote) {
                    parts.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            parts.push(current.trim());
            return parts;
        });
        console.log(`Database loaded: ${taskDatabase.length} entries.`);
    }
  } catch (e) {
    console.error("Data parse error", e);
    document.querySelector('#tableBody').innerHTML = '<tr><td colspan="5">æ•°æ®è§£æé”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°</td></tr>';
  }
}

// 2. Scroll Handling (Prevent Swiper interference)
function setupScrollHandling() {
    const stopPropagation = (e) => e.stopPropagation();
    
    // Elements that need independent scrolling
    const scrollables = [
        document.getElementById('inputData'),
        document.querySelector('.table-wrapper')
    ];

    scrollables.forEach(el => {
        if(!el) return;
        // Desktop
        el.addEventListener('wheel', (e) => {
             // Stop bubble so Swiper doesn't move
             e.stopPropagation(); 
        }, { passive: false });
        
        // Touch (Mobile)
        el.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: true });
        
        el.addEventListener('touchmove', (e) => {
            e.stopPropagation();
            // Optional: logic to prevent body scroll at boundaries could go here
        }, { passive: true });
    });
}

// 3. Search Logic (Enhanced with Levenshtein Distance for typos)
function findTask(line) {
    const input = line.trim();
    if (!input) return null;

    // Split "Character - Task"
    const separators = [' - ', ' â€“ ', ' â€” ', '-', 'â€“'];
    let charName = '', taskName = input;
    
    for (const sep of separators) {
        if (input.includes(sep)) {
            const parts = input.split(sep);
            charName = parts[0].trim();
            taskName = parts.slice(1).join(sep).trim();
            break;
        }
    }

    // Normalize
    const normTask = taskName.toLowerCase().replace(/['"â€™]/g, "");
    const normChar = charName.toLowerCase().replace(/['"â€™]/g, "");
    
    // --- Helper 1: Bidirectional Keyword Match ---
    const isKeywordMatch = (inputStr, targetStr) => {
        const getWords = (s) => s.split(/\s+/).filter(w => w.length > 0);
        const inputWords = getWords(inputStr);
        const targetWords = getWords(targetStr);
        if (inputWords.length === 0 || targetWords.length === 0) return false;
        
        // Input is subset of Target OR Target is subset of Input
        const inputIsSubset = inputWords.every(word => targetStr.includes(word));
        const targetIsSubset = targetWords.every(word => inputStr.includes(word));
        return inputIsSubset || targetIsSubset;
    };

    // --- Helper 2: Levenshtein Distance (For Typos like "Faily" -> "Fairy") ---
    const getEditDistance = (a, b) => {
        if(a.length === 0) return b.length;
        if(b.length === 0) return a.length;
        
        const matrix = [];
        for(let i = 0; i <= b.length; i++) matrix[i] = [i];
        for(let j = 0; j <= a.length; j++) matrix[0][j] = j;

        for(let i = 1; i <= b.length; i++){
            for(let j = 1; j <= a.length; j++){
                if(b.charAt(i-1) === a.charAt(j-1)){
                    matrix[i][j] = matrix[i-1][j-1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i-1][j-1] + 1, // substitution
                        Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1) // insertion/deletion
                    );
                }
            }
        }
        return matrix[b.length][a.length];
    };

    // --- Helper 3: Typo Match Logic ---
    const isTypoMatch = (inputStr, targetStr) => {
        // Optimization: Don't check if length difference is too big
        if (Math.abs(inputStr.length - targetStr.length) > 3) return false;
        
        const dist = getEditDistance(inputStr, targetStr);
        const maxLength = Math.max(inputStr.length, targetStr.length);
        
        // Similarity Threshold: > 80% similarity
        // e.g. "Faily" vs "Fairy" (Length 5, Dist 1) -> 80% -> Match
        // e.g. "Read Faily Tales" (Length 16, Dist 1) -> 93% -> Match
        return (1 - dist / maxLength) >= 0.8;
    };

    // ====== SEARCH EXECUTION ======

    // Strategy 1: Search within specific Character
    if (charName) {
        const charTasks = taskDatabase.filter(row => row[0].toLowerCase() === normChar);
        
        if (charTasks.length > 0) {
            // 1.1 Exact
            const exact = charTasks.find(row => row[4].toLowerCase().replace(/['"â€™]/g, "") === normTask);
            if (exact) return { data: exact, type: 'Exact' };
            
            // 1.2 Fuzzy Substring
            const fuzzy = charTasks.find(row => {
                const rowTask = row[4].toLowerCase().replace(/['"â€™]/g, "");
                return rowTask.includes(normTask) || normTask.includes(rowTask);
            });
            if (fuzzy) return { data: fuzzy, type: 'Fuzzy' };

            // 1.3 Keyword Subset
            const keywordMatch = charTasks.find(row => {
                const rowTask = row[4].toLowerCase().replace(/['"â€™]/g, "");
                return isKeywordMatch(normTask, rowTask);
            });
            if (keywordMatch) return { data: keywordMatch, type: 'Keyword' };

            // 1.4 Typo/Levenshtein Match (New!)
            const typoMatch = charTasks.find(row => {
                const rowTask = row[4].toLowerCase().replace(/['"â€™]/g, "");
                return isTypoMatch(normTask, rowTask);
            });
            if (typoMatch) return { data: typoMatch, type: 'Typo Match' };
        }
    }

    // Strategy 2: Global Search
    // 2.1 Global Exact
    const globalMatch = taskDatabase.find(row => row[4].toLowerCase().replace(/['"â€™]/g, "") === normTask);
    if (globalMatch) return { data: globalMatch, type: 'Global Exact' };

    // 2.2 Global Keyword (Length > 3)
    if (normTask.length > 3) { 
        const globalKeyword = taskDatabase.find(row => {
            const rowTask = row[4].toLowerCase().replace(/['"â€™]/g, "");
            return isKeywordMatch(normTask, rowTask);
        });
        if (globalKeyword) return { data: globalKeyword, type: 'Global Keyword' };
        
        // 2.3 Global Typo Match (Only for longer phrases to avoid false positives)
        // e.g. Don't match "Hat" to "Cat" globally, but "Magic Kindom" -> "Magic Kingdom" is ok
        if (normTask.length > 6) {
            const globalTypo = taskDatabase.find(row => {
                const rowTask = row[4].toLowerCase().replace(/['"â€™]/g, "");
                return isTypoMatch(normTask, rowTask);
            });
            if (globalTypo) return { data: globalTypo, type: 'Global Typo' };
        }
    }

    return null;
}

// 4. Main Function
function translateTasks() {
    const input = document.getElementById('inputData').value;
    const lines = input.split('\n').filter(l => l.trim());
    
    currentTableData = [];
    let found = 0, notFound = 0;

    if (taskDatabase.length === 0) initDatabase();

    lines.forEach(line => {
        const res = findTask(line);
        if (res) {
            found++;
            const d = res.data;
            // Format: Name+Level
            let charStr = `${d[0]} (Lv.${d[1]})`;
            if (d[2]) charStr += ` + ${d[2]} (Lv.${d[3]})`;
            
            // Format: Extra (Building, Tokens etc)
            let extras = [];
            if(d[7] && d[7] !== "") extras.push(`Drop: ${d[7]}`); // Happy/Token
            if(d[8] && !d[8].includes("Coming Soon")) extras.push(d[8]);

            currentTableData.push({
                char: charStr,
                task: d[4],
                time: d[5],
                timeVal: parseDuration(d[5]), // For sorting
                build: d[6],
                extra: extras.join(', ')
            });
        } else {
            notFound++;
            currentTableData.push({
                char: line.split(/[-â€“]/)[0].trim() || 'Unknown',
                task: line,
                time: '-',
                timeVal: 0,
                build: '-',
                extra: 'Not Found'
            });
        }
    });

    renderTable();
	document.getElementById('tableStats').innerHTML = 
  `<span style="margin-right:15px">âœ… Found: <b>${found}</b></span> 
   <span style="color:#e53e3e">âŒ Missing: <b>${notFound}</b></span>`;
}

// Helper: Parse "60m", "12h", "6m" into minutes for sorting
function parseDuration(str) {
    if(!str || str === '-') return 0;
    str = str.toLowerCase();
    if(str.includes('h')) return parseFloat(str) * 60;
    if(str.includes('m')) return parseFloat(str);
    if(str.includes('s')) return parseFloat(str) / 60;
    return 0;
}

function renderTable() {
    const tbody = document.getElementById('tableBody');
    if (currentTableData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;padding:20px">æ— æ•°æ®</td></tr>';
        return;
    }
    
    tbody.innerHTML = currentTableData.map(row => `
        <tr>
            <td title="${row.char}">${row.char}</td>
            <td title="${row.task}">${row.task}</td>
            <td>${row.time}</td>
            <td title="${row.build}">${row.build}</td>
            <td title="${row.extra}">${row.extra}</td>
        </tr>
    `).join('');
}

// 5. Sorting
function sortTable(colIndex) {
    const keys = ['char', 'task', 'timeVal', 'build', 'extra'];
    const key = keys[colIndex];
    
    // Toggle direction
    sortDirection[colIndex] = !sortDirection[colIndex];
    const isAsc = sortDirection[colIndex];

    // Update Header Arrows
    document.querySelectorAll('th').forEach((th, idx) => {
        th.classList.remove('asc', 'desc');
        if(idx === colIndex) th.classList.add(isAsc ? 'asc' : 'desc');
    });

    currentTableData.sort((a, b) => {
        let valA = a[key];
        let valB = b[key];
        
        // String comparison
        if (typeof valA === 'string') valA = valA.toLowerCase();
        if (typeof valB === 'string') valB = valB.toLowerCase();

        if (valA < valB) return isAsc ? -1 : 1;
        if (valA > valB) return isAsc ? 1 : -1;
        return 0;
    });

    renderTable();
}

// Init logic on load
document.addEventListener('DOMContentLoaded', () => {
    initDatabase();
    setupScrollHandling();
});

// Export for button access
window.translateTasks = translateTasks;
window.sortTable = sortTable;

</script>
</body>
</html>
